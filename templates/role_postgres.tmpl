package {{.Package}}

import (
	"database/sql"
{{if .IsMonolith}}
	"{{.RoleEntityImport}}"
	"{{.RoleRepositoryImport}}"
	userEntity "{{.UserEntityImport}}"
{{else}}
	"{{.ModuleName}}/internal/domain/entity"
	"{{.ModuleName}}/internal/domain/repository"
	userEntity "{{.ModuleName}}/internal/user/domain/entity"
{{end}}
)

// roleRepository implements the RoleRepository interface using PostgreSQL
type roleRepository struct {
	db *sql.DB
}

// NewRoleRepository creates a new role repository
func NewRoleRepository(db *sql.DB) repository.RoleRepository {
	return &roleRepository{db: db}
}

// Create creates a new role
func (r *roleRepository) Create(role *entity.Role) error {
	_, err := r.db.Exec("INSERT INTO roles (name, is_active) VALUES ($1, $2)", role.Name, role.IsActive)
	return err
}

// FindByID finds a role by ID
func (r *roleRepository) FindByID(id uint) (*entity.Role, error) {
	var role entity.Role
	err := r.db.QueryRow("SELECT id, name, is_active, created_at, updated_at FROM roles WHERE id = $1", id).Scan(
		&role.ID, &role.Name, &role.IsActive, &role.CreatedAt, &role.UpdatedAt)
	if err != nil {
		return nil, err
	}
	return &role, nil
}

// FindByName finds a role by name
func (r *roleRepository) FindByName(name string) (*entity.Role, error) {
	var role entity.Role
	err := r.db.QueryRow("SELECT id, name, is_active, created_at, updated_at FROM roles WHERE name = $1", name).Scan(
		&role.ID, &role.Name, &role.IsActive, &role.CreatedAt, &role.UpdatedAt)
	if err != nil {
		return nil, err
	}
	return &role, nil
}

// Update updates a role
func (r *roleRepository) Update(role *entity.Role) error {
	_, err := r.db.Exec("UPDATE roles SET name = $1, is_active = $2, updated_at = NOW() WHERE id = $3",
		role.Name, role.IsActive, role.ID)
	return err
}

// Delete deletes a role
func (r *roleRepository) Delete(id uint) error {
	_, err := r.db.Exec("DELETE FROM roles WHERE id = $1", id)
	return err
}

// FindAll finds all roles with pagination
func (r *roleRepository) FindAll(limit, offset int) ([]*entity.Role, error) {
	rows, err := r.db.Query("SELECT id, name, is_active, created_at, updated_at FROM roles LIMIT $1 OFFSET $2", limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var roles []*entity.Role
	for rows.Next() {
		var role entity.Role
		err := rows.Scan(&role.ID, &role.Name, &role.IsActive, &role.CreatedAt, &role.UpdatedAt)
		if err != nil {
			return nil, err
		}
		roles = append(roles, &role)
	}
	return roles, nil
}

// FindByStatus finds roles by status with pagination
func (r *roleRepository) FindByStatus(isActive bool, limit, offset int) ([]*entity.Role, error) {
	rows, err := r.db.Query("SELECT id, name, is_active, created_at, updated_at FROM roles WHERE is_active = $1 LIMIT $2 OFFSET $3", isActive, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var roles []*entity.Role
	for rows.Next() {
		var role entity.Role
		err := rows.Scan(&role.ID, &role.Name, &role.IsActive, &role.CreatedAt, &role.UpdatedAt)
		if err != nil {
			return nil, err
		}
		roles = append(roles, &role)
	}
	return roles, nil
}

// Count returns total number of roles
func (r *roleRepository) Count() (int64, error) {
	var count int64
	err := r.db.QueryRow("SELECT COUNT(*) FROM roles").Scan(&count)
	return count, err
}

// FindByIDWithPermissions finds a role by ID (simplified without permissions)
func (r *roleRepository) FindByIDWithPermissions(id uint) (*entity.Role, error) {
	var role entity.Role
	err := r.db.QueryRow("SELECT id, name, is_active, created_at, updated_at FROM roles WHERE id = $1", id).Scan(
		&role.ID, &role.Name, &role.IsActive, &role.CreatedAt, &role.UpdatedAt)
	if err != nil {
		return nil, err
	}
	return &role, nil
}

// AssignPermission assigns a permission to a role
func (r *roleRepository) AssignPermission(roleID, permissionID uint) error {
	// Check if association already exists
	var count int64
	err := r.db.QueryRow("SELECT COUNT(*) FROM role_permissions WHERE role_id = $1 AND permission_id = $2", roleID, permissionID).Scan(&count)
	if err != nil {
		return err
	}
	if count > 0 {
		return nil // Already assigned
	}

	// Create association
	_, err = r.db.Exec("INSERT INTO role_permissions (role_id, permission_id) VALUES ($1, $2)", roleID, permissionID)
	return err
}

// RemovePermission removes a permission from a role
func (r *roleRepository) RemovePermission(roleID, permissionID uint) error {
	_, err := r.db.Exec("DELETE FROM role_permissions WHERE role_id = $1 AND permission_id = $2", roleID, permissionID)
	return err
}

// FindRolesByPermission finds roles by permission name (simplified)
func (r *roleRepository) FindRolesByPermission(permissionName string) ([]*entity.Role, error) {
	// Simplified implementation - return empty slice
	return []*entity.Role{}, nil
}

func (r *roleRepository) GetRoleUsers(roleID uint) ([]*userEntity.User, error) {
	// Simplified implementation - return empty slice
	return []*userEntity.User{}, nil
}

// GetUserRoles gets roles assigned to a user
func (r *roleRepository) GetUserRoles(userID uint) ([]*entity.Role, error) {
	// Simplified implementation - return empty slice
	return []*entity.Role{}, nil
}

// SearchByName searches roles by name
func (r *roleRepository) SearchByName(query string, limit, offset int) ([]*entity.Role, error) {
	rows, err := r.db.Query("SELECT id, name, is_active, created_at, updated_at FROM roles WHERE name ILIKE $1 LIMIT $2 OFFSET $3", "%"+query+"%", limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var roles []*entity.Role
	for rows.Next() {
		var role entity.Role
		err := rows.Scan(&role.ID, &role.Name, &role.IsActive, &role.CreatedAt, &role.UpdatedAt)
		if err != nil {
			return nil, err
		}
		roles = append(roles, &role)
	}
	return roles, nil
}

// FindRolesCreatedBetween finds roles created between dates (simplified)
func (r *roleRepository) FindRolesCreatedBetween(startDate, endDate string) ([]*entity.Role, error) {
	// Simplified implementation - return empty slice
	return []*entity.Role{}, nil
}
